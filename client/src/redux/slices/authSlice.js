import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { login as authLogin, register as authRegister } from '../../api/auth'
import { toast } from 'react-toastify'
import { getUserProfile } from '../../api/user'

export const register =
	({ firstname, lastname, username, email, password }) =>
	async (dispatch) => {
		const jobClassification = 'Apps Dev Sr Programmer Analyst'
		const position = 'AVP'
		const locationStreet = '3800 CITIGROUP CENTER DRIVE '
		const locationCity = 'Tampa FL - Florida US 33610-9122'
		const employeeId = 'oz46493'

		try {
			const response = await authRegister({
				firstname,
				lastname,
				username,
				email,
				password,
				jobClassification,
				position,
				locationStreet,
				locationCity,
				employeeId
			})

			dispatch(registerSuccess)

			toast('Registration Successful!ðŸ”¥ðŸ™Œ', {
				position: 'top-right',
				autoClose: 1000,
				hideProgressBar: false,
				closeOnClick: true,
				pauseOnHover: true,
				draggable: true,
				progress: undefined
			})

			return response
		} catch (error) {
			toast('Oh no! Registration Failed!ðŸ˜¢', {
				position: 'top-right',
				autoClose: 1000,
				hideProgressBar: false,
				closeOnClick: true,
				pauseOnHover: true,
				draggable: true,
				progress: undefined
			})

			dispatch(registerFail)
			return Promise.reject({ message: error })
		}
	}

export const login = createAsyncThunk(
	'auth/loginSuccess',
	async ({ username, password }, { rejectWithValue }) => {
		try {
			const auth = await authLogin(username, password)
			localStorage.setItem('auth', JSON.stringify(auth.data))
			const user = await getUserProfile(auth.data.accountId)
			return { auth: { ...auth.data }, user: { ...user.data } }
		} catch (error) {
			return rejectWithValue(error);
		}
	}
)

export const updateAuth = (updatedUser) => (dispatch) => {
	localStorage.setItem('auth', JSON.stringify(updatedUser))
	// append () even if the action payload is empty or redux state will not update
	dispatch(update(updatedUser))
}

export const logout = () => (dispatch) => {
	localStorage.removeItem('auth')
	// append () even if the action payload is empty or redux state will not update
	dispatch(logOut())
}

// get user object from browser storage
const auth = JSON.parse(localStorage.getItem('auth'))

const initialState = auth
	? { isLoggedIn: true, ...auth }
	: { isLoggedIn: false }

// create redux slice
export const authSlice = createSlice({
	name: 'auth',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		// <action-name>: (state) => {
		registerSuccess: (state) => {
			// Redux Toolkit allows us to write "mutating" logic in reducers. It
			// doesn't actually mutate the state because it uses the Immer library,
			// which detects changes to a "draft state" and produces a brand new
			// immutable state based off those changes
			return {
				...state,
				isLoggedIn: false
			}
		},
		registerFail: (state) => {
			return {
				...state,
				isLoggedIn: false
			}
		},
		logOut: () => {
			return {
				isLoggedIn: false
			}
		},
		update: (state, action) => {
			return {
				...state,
				...action.payload
			}
		}
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			// available actions types for createAsyncThunk
			//   - fulfilled
			//   - pending
			//   - rejected
			.addCase(login.fulfilled, (state, action) => {
				return {
					...state,
					isLoggedIn: true,
					...action.payload.auth
				}
			})
			.addCase(login.rejected, () => {
				toast.error('Login Failed', {
					position: 'top-right',
					autoClose: 1000,
					hideProgressBar: false,
					closeOnClick: true,
					pauseOnHover: true,
					draggable: true,
					progress: undefined
				})
				return { isLoggedIn: false }
			})
	}
})

// export the actions from this slice
export const { registerSuccess, registerFail, logOut, update } =
	authSlice.actions

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectAuthUser = (state) => state.auth
export const selectAccountId = (state) => state.auth.accountId

// export the reducers from this slice
export default authSlice.reducer
