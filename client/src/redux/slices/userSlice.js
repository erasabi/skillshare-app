import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { getUserProfile, setMentorProfile, setUserById } from '../../api/user'
import { login, logOut } from './authSlice'

export const getUser = createAsyncThunk('user/getUser', async () => {
	try {
		const { accountId } = JSON.parse(localStorage.getItem('auth'))
		// if token needs refresh, do so then re-try the the call
		const { data } = await getUserProfile(accountId)
		// check if response data is for userProfile before updating state
		return { ...data }
	} catch (error) {
		return error
	}
})

// updates current mentor skills
export const updateMentorSkills =
	(accountId, updatedMentorProfile) => async (dispatch) => {
		try {
			const body = {
				accountId: accountId,
				mentorProfile: updatedMentorProfile
			}
			await setMentorProfile(body)
			dispatch(updateMentorProfile(updatedMentorProfile))
		} catch (error) {
			return error
		}
	}

// updates current mentor skills
export const updateUser = (updatedUser) => async (dispatch) => {
	try {
		await setUserById(updatedUser)
		dispatch(update(updatedUser))
	} catch (error) {
		return error
	}
}

export const toggleDarkModeEnabled = (updatedUser) => async (dispatch) => {
	try {
		await setUserById(updatedUser)
		dispatch(update(updatedUser))
	} catch (error) {
		return error
	}
}

const initialState = {
	isFetching: true
}

const userSlice = createSlice({
	name: 'user',
	initialState: initialState,
	reducers: {
		update(state, action) {
			return {
				...state,
				...action.payload
			}
		},
		updateMentorProfile(state, action) {
			return {
				...state,
				mentorProfile: action.payload
			}
		},
		toggleDarkModeEnabled(state, action) {
			return {
				...state,
				darkModeEnabled: !action.payload
			}
		}
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		// available actions types for createAsyncThunk
		//   - fulfilled
		//   - pending
		//   - rejected
		// @ts-ignore
		builder
			.addCase(login.fulfilled, (state, action) => {
				return {
					...state,
					...action.payload.user
				}
			})
			.addCase(logOut, () => {
				return {}
			})
			.addCase(getUser.fulfilled, (state, action) => {
				return {
					...state,
					isFetching: false,
					...action.payload
				}
			})
			.addCase(getUser.pending, (state) => {
				return {
					...state,
					isFetching: true
				}
			})
			.addCase(getUser.rejected, (state) => {
				return {
					...state,
					isFetching: false
				}
			})
	}
})

// The function(s) below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectUser = (state) => state.user
export const selectUserAccountId = (state) => state.user.accountId
export const selectUserProfile = (state) => state.user.userProfile
export const selectUserSkills = (state) => state.user.mentorProfile.skills
export const selectTotalMentorHours = (state) =>
	state.user.mentorProfile.totalMentorHours
export const selectDarkModeEnabled = (state) => state.user.darkModeEnabled

export const { updateMentorProfile, update } = userSlice.actions

export default userSlice.reducer
